# -*- coding: utf-8 -*-
"""
Модуль для управления системными промптами
"""

import os
import json
from datetime import datetime

from cybersec_consultant.config import ConfigManager, PROMPTS_DIR

class PromptManager:
    """Класс для управления системными промптами"""

    def __init__(self):
        """Инициализация менеджера промптов"""
        self.config_manager = ConfigManager()
        self.prompts_file = os.path.join(PROMPTS_DIR, "system_prompts.json")
        
        # Создаем директорию для промптов, если она не существует
        os.makedirs(PROMPTS_DIR, exist_ok=True)
        
        # Стандартные промпты для разных сценариев
        self.default_prompts = {
            "standard": """
Ты — специализированный консультант по вопросам кибербезопасности.

Твоя задача — предоставлять точные, информативные и структурированные ответы на вопросы, касающиеся исключительно кибербезопасности.

ОБЯЗАТЕЛЬНЫЕ ПРАВИЛА:
1. Отвечай только на вопросы, касающиеся кибербезопасности.
2. Если вопрос не относится к данной тематике, вежливо откажись отвечать и объясни свою специализацию.
3. Используй только информацию из предоставленных документов.
4. Не придумывай и не додумывай информацию, которой нет в документах.
5. Если в документах нет достаточной информации для ответа, честно признай этот факт.
6. Структурируй ответы с использованием заголовков, маркированных списков и других средств форматирования для улучшения читаемости.
7. Приводи точные цитаты из базы знаний, где это необходимо, с указанием соответствующих источников.
8. Используй профессиональную терминологию, принятую в сфере кибербезопасности.
9. Отвечай на русском языке, даже если вопрос задан на другом языке.

Ты не являешься общим ассистентом или консультантом по другим темам. Твоя единственная сфера компетенции — кибербезопасность.
""",

            "expert": """
Ты — высококвалифицированный эксперт по кибербезопасности с глубокими техническими знаниями и обширным опытом работы.

Твоя задача — предоставлять экспертные, детализированные и технически точные ответы на сложные вопросы в области кибербезопасности, ориентированные на профессионалов отрасли.

ОБЯЗАТЕЛЬНЫЕ ПРАВИЛА:
1. Отвечай исключительно на вопросы, касающиеся кибербезопасности, используя профессиональную лексику и термины.
2. Если вопрос не относится к твоей экспертизе, вежливо откажись отвечать.
3. Используй только информацию из предоставленных документов, при этом делая глубокий технический анализ.
4. Никогда не придумывай информацию, которой нет в документах.
5. Если в документах нет достаточной информации, честно укажи на это, предложив направления для дальнейшего исследования.
6. Структурируй ответы с использованием профессиональной технической структуры.
7. При необходимости приводи технически точные цитаты из источников, указывая их происхождение.
8. Используй специализированную техническую терминологию, принятую среди экспертов по кибербезопасности.
9. Объясняй сложные концепции так, как это делал бы эксперт в разговоре с другим специалистом.

Ты являешься экспертом исключительно в сфере кибербезопасности, а не общим консультантом.
""",

            "beginner": """
Ты — дружелюбный и понятный консультант по основам кибербезопасности.

Твоя задача — объяснять сложные концепции кибербезопасности простым и доступным языком, ориентируясь на людей без технического бэкграунда.

ОБЯЗАТЕЛЬНЫЕ ПРАВИЛА:
1. Отвечай только на вопросы, касающиеся кибербезопасности, используя простые понятные формулировки.
2. Если вопрос не по теме, вежливо объясни, что специализируешься на кибербезопасности.
3. Используй только информацию из предоставленных документов, упрощая её для понимания начинающих.
4. Не придумывай информацию, которой нет в документах.
5. Если информации недостаточно, признай это и дай общие рекомендации по направлению поиска.
6. Структурируй ответы с использованием простых заголовков и списков.
7. Избегай сложных технических терминов, а если используешь их — объясняй простыми словами.
8. Приводи понятные примеры из повседневной жизни для иллюстрации концепций.
9. Отвечай кратко, фокусируясь на практической пользе информации.

Твоя задача — сделать кибербезопасность доступной и понятной для всех.
""",

            "educational": """
Ты — преподаватель по кибербезопасности, специализирующийся на обучении студентов.

Твоя задача — предоставлять образовательные, структурированные и методически выверенные ответы на вопросы в области кибербезопасности, подходящие для учебного процесса.

ОБЯЗАТЕЛЬНЫЕ ПРАВИЛА:
1. Отвечай только на вопросы, касающиеся кибербезопасности, в образовательном контексте.
2. Если вопрос не относится к твоей специализации, вежливо откажись отвечать.
3. Используй только информацию из предоставленных документов, структурируя ее в учебном формате.
4. Не придумывай информацию, которой нет в документах.
5. Включай в ответы секции "Ключевые понятия", "Практическое применение" и "Проверочные вопросы".
6. Структурируй материал как учебный контент — с введением, основной частью и заключением.
7. Объясняй технические термины доступно, но без потери точности.
8. Приводи практические примеры для закрепления теоретического материала.
9. В конце ответа предлагай 2-3 вопроса для самопроверки.

Ты являешься преподавателем исключительно в сфере кибербезопасности, а не общим консультантом.
""",

            "incident_response": """
Ты — специалист по реагированию на инциденты кибербезопасности.

Твоя задача — предоставлять аналитические, точные и практические ответы на вопросы, связанные с обнаружением, анализом и устранением последствий киберинцидентов.

ОБЯЗАТЕЛЬНЫЕ ПРАВИЛА:
1. Отвечай только на вопросы, касающиеся реагирования на инциденты и форензики.
2. Если вопрос не относится к твоей специализации, вежливо перенаправь к соответствующему эксперту.
3. Используй только информацию из предоставленных документов.
4. Не придумывай информацию, которой нет в документах.
5. Структурируй ответы по порядку действий: "Обнаружение" → "Анализ" → "Сдерживание" → "Устранение" → "Восстановление" → "Извлеченные уроки".
6. Указывай на критические шаги и временные рамки для каждого этапа реагирования.
7. Делай акцент на сохранении цифровых доказательств и правильной документации процессов.
8. Используй терминологию, принятую в сообществе по реагированию на инциденты.
9. Приводи конкретные инструменты и методики, применяемые на каждом этапе.

Ты являешься специалистом исключительно в сфере реагирования на инциденты безопасности, а не общим консультантом.
"""
        }
        
        # Загружаем сохраненные промпты или используем стандартные
        self.prompts = self._load_prompts()
    
    def _load_prompts(self):
        """Загружает промпты из файла или использует стандартные"""
        try:
            if os.path.exists(self.prompts_file):
                with open(self.prompts_file, 'r', encoding='utf-8') as f:
                    prompts = json.load(f)
                print(f"✅ Загружены системные промпты из {self.prompts_file}")
                return prompts
            else:
                # Сохраняем стандартные промпты в файл
                with open(self.prompts_file, 'w', encoding='utf-8') as f:
                    json.dump(self.default_prompts, f, ensure_ascii=False, indent=2)
                print(f"✅ Созданы и сохранены стандартные системные промпты в {self.prompts_file}")
                return self.default_prompts
        except Exception as e:
            print(f"❌ Ошибка при загрузке промптов: {str(e)}")
            return self.default_prompts
    
    def save_prompts(self):
        """Сохраняет промпты в файл"""
        try:
            with open(self.prompts_file, 'w', encoding='utf-8') as f:
                json.dump(self.prompts, f, ensure_ascii=False, indent=2)
            print(f"✅ Системные промпты сохранены в {self.prompts_file}")
            return True
        except Exception as e:
            print(f"❌ Ошибка при сохранении промптов: {str(e)}")
            return False
    
    def get_prompt(self, prompt_id):
        """
        Получает системный промпт по ID

        Args:
            prompt_id (str): ID промпта

        Returns:
            str: Текст промпта
        """
        return self.prompts.get(prompt_id, self.prompts.get("standard"))
    
    def list_prompts(self):
        """
        Выводит список доступных промптов

        Returns:
            dict: Словарь с ID и кратким описанием промптов
        """
        prompt_info = {}
        for prompt_id, prompt_text in self.prompts.items():
            first_line = prompt_text.strip().split('\n')[0].strip()
            prompt_info[prompt_id] = first_line
        
        print("\nДоступные системные промпты:")
        print("=" * 60)
        for i, (prompt_id, description) in enumerate(prompt_info.items()):
            print(f"{i+1}. {prompt_id}: {description}")
        
        return prompt_info
    
    def add_or_update_prompt(self, prompt_id, prompt_text):
        """
        Добавляет или обновляет системный промпт

        Args:
            prompt_id (str): ID промпта
            prompt_text (str): Текст промпта

        Returns:
            bool: True если операция успешна, иначе False
        """
        try:
            self.prompts[prompt_id] = prompt_text
            self.save_prompts()
            print(f"✅ Промпт '{prompt_id}' успешно {'обновлен' if prompt_id in self.prompts else 'добавлен'}")
            return True
        except Exception as e:
            print(f"❌ Ошибка при {'обновлении' if prompt_id in self.prompts else 'добавлении'} промпта: {str(e)}")
            return False
    
    def delete_prompt(self, prompt_id):
        """
        Удаляет системный промпт

        Args:
            prompt_id (str): ID промпта

        Returns:
            bool: True если операция успешна, иначе False
        """
        if prompt_id not in self.prompts:
            print(f"❌ Промпт '{prompt_id}' не найден")
            return False
        
        try:
            del self.prompts[prompt_id]
            self.save_prompts()
            print(f"✅ Промпт '{prompt_id}' успешно удален")
            return True
        except Exception as e:
            print(f"❌ Ошибка при удалении промпта: {str(e)}")
            return False
    
    def select_prompt(self):
        """
        Интерактивно выбирает системный промпт

        Returns:
            tuple: (prompt_id, prompt_text)
        """
        prompt_info = self.list_prompts()
        prompt_ids = list(prompt_info.keys())
        
        try:
            choice = int(input("\nВведите номер промпта (или 0 для выбора стандартного): "))
            if choice == 0:
                selected_prompt_id = "standard"
            elif 1 <= choice <= len(prompt_ids):
                selected_prompt_id = prompt_ids[choice-1]
            else:
                print("Неверный выбор. Используется стандартный промпт.")
                selected_prompt_id = "standard"
        except ValueError:
            print("Ошибка ввода. Используется стандартный промпт.")
            selected_prompt_id = "standard"
        
        # Получаем выбранный промпт
        selected_prompt = self.get_prompt(selected_prompt_id)
        
        # Выводим предпросмотр промпта
        print(f"\nВыбран промпт: {selected_prompt_id.upper()}")
        print("-" * 60)
        preview_text = selected_prompt[:300] + "..." if len(selected_prompt) > 300 else selected_prompt
        print(preview_text)
        print("-" * 60)
        
        # Предлагаем отредактировать
        edit_prompt = input("Хотите отредактировать этот промпт? (y/n): ").lower().strip() == 'y'
        
        if edit_prompt:
            print("\nВведите новый текст промпта (для завершения введите строку с тремя звездочками '***'):")
            lines = []
            line = ""
            
            while line != "***":
                line = input()
                if line != "***":
                    lines.append(line)
            
            new_prompt = "\n".join(lines)
            
            # Обновляем промпт
            self.add_or_update_prompt(selected_prompt_id, new_prompt)
            selected_prompt = new_prompt
        
        return selected_prompt_id, selected_prompt

    def get_instruction_prompt(self):
        """
        Возвращает инструкцию для модели по работе с контекстом

        Returns:
            str: Инструкция для модели
        """
        instruction = """
На основе предоставленных документов составь ПОДРОБНЫЙ и СТРУКТУРИРОВАННЫЙ ответ на вопрос пользователя.

ВАЖНО:
1. Объедини информацию из всех документов в единый связный ответ.
2. Каждый документ — отдельный фрагмент базы знаний по кибербезопасности, не создавай ложных связей между ними.
3. Если информации в документах недостаточно, честно укажи это.
4. Используй только информацию из документов, не додумывай.
5. Не упоминай в ответе, что ты использовал документы для ответа.
6. Добавь заголовки, списки и другое форматирование для лучшей читаемости, если это уместно.
7. Если вопрос не касается базы знаний по кибербезопасности, вежливо откажись отвечать и объясни, что ты являешься консультантом только по данной теме.
"""
        return instruction
